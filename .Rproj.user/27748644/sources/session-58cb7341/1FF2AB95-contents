---
title: "Tarea 1 Genómica Funcional 2023"
author: "Roberto Álvarez"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document: 
    fig_height: 8
    fig_width: 13
    number_section: yes
    theme: cerulean
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
  html_notebook: 
    number_sections: yes
    toc: yes
#bibliography: biblio.bib
#csl: nature.csl
#runtime: shiny
#output: flexdashboard::flex_dashboard
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Tarea 1
## (20 %) Preguntas rápidas (simples)
1. Considera una red de 10 nodos . Considera que tienes una sola conexión. ¿Cuál es el número máximo de nodos que puedes conectar? Dado un solo nodo , ¿cuál es el número máximo conexiones que puede tener tal nodo?

R=La máxima de ndoos que s epueden conectar coon una sola conexión son dos

 $$L= \dfrac{N(N-1)}{2} = Limite \\ \\
 L= \dfrac{10(10-1)}{2} = 
 90/2 =45$$
R= 45 es el numero máximo de nodos que se puede conectar

R= El número máximo de conexiones que s epuede obtener es de 9, de 10 si pemritimos que se conecte así mismo



2. Considera una red dirigida de 10 nodos. Usa 25 conexiones y dibuja una red con ese número de nodos y conexiones dirigidas. Calcula la distribución de conectividades de salida.Calcula el número total de conexiones de salida ¿Cómo se compara el número total de de conectividades  de entrada (son iguales, diferentes)? Explica tu respuesta. Calcula el promedio de entrada y de salida. Discute tu resultado.

```{r message=FALSE, warning=FALSE}
library(igraph)
ask2 <- random.graph.game(10,25,type= "gnm", directed = T) #el numero 25 lo toma como
#probabilidad, por eso hay que ponerle que es tipo "gnm" para que en vez de tomarlo como
#probabilidad lo tome como numero de conexiones
ask2

plot(ask2)

outdis <- degree.distribution(ask2, mode="out")
plot(outdis)

salida <- degree(ask2, mode="out") #nos da el total de conexiones d eentrada
sum(salida)

entrada <- degree(ask2, mode="in")
sum(entrada)

#dan el mismo valor, por que en si, loq eu esta saliendo de un nodo, debe de entrar a otro
#a menos que ese nodo solo salga y se quede "varado" en el infinito y nunca entre nada
#algo que no pasa, pq los nodos que salen si se conectan implican que tambien entran


mean(entrada)
mean(salida)

```

3. Considera una red no dirigida de $n=3,4,5,6$ nodos respectivamente. ¿Cuál es el número máximo de conexiones que puedes poner? Dibuja cada caso. 
R= Sacamos los valores máximos de cada red, con la formula que esta debajo

$$ L= \dfrac{N(N-1)}{2} = Limite \\\\$$
 $$\textbf{n=3 }. L= \dfrac{3(3-1)}{2}= 3\\\\$$
 $$ \textbf{n=4}. L= \dfrac{4(4-1)}{2}= 6\\\\$$
 $$  \textbf{n=5 }. L= \dfrac{5(5-1)}{2}= 10\\\\$$
   $$ \textbf{n=6}. L= \dfrac{6(6-1)}{2}= 15\\\\$$
```{r message=FALSE, warning=FALSE}
library(igraph)
nod3 <- random.graph.game(3,3,type= "gnm", directed = F)
plot(nod3)
nod4 <- random.graph.game(4,6,type= "gnm", directed = F)
plot(nod4)
nod5 <- random.graph.game(5,10,type= "gnm", directed =F)
plot(nod5)
nod6 <- random.graph.game(6,15,type= "gnm", directed =F)
plot(nod6)
```
¿Qué pasa si la red es dirigida? R= Si la red es dirigida le permite tener más conexiones entre nodos, por que ahora hay dirección y puede haber una de emisión y una de receptor. 



4. Considera tu red de amigos reales.¿ Cuál es tu coeficiente de clusterización?

```{r}
library(igraph)

amigosreales <- read.csv("GF_Tarea_01_2023_files1/red_reales.csv")

amigosreales <- amigosreales[,-1]
rownames(amigosreales) <- colnames(amigosreales)

amigosreales <- as.matrix(amigosreales)


redreales <- graph_from_adjacency_matrix(amigosreales, mode= "undirected")


plot(redreales)

transitivity(redreales, type = "local") #sacamos el coeficiente de lcusterizacion de cada persona y como soy la primera persona el coeficiente de 0.33 es mio

V(redreales)$name[1]



```
Mi coeficiente de clusterización es de 0.3380, no se si pueda ser por que mis amigos, se divide en 3 grupos, como tipo división, peor la mayoria de mis grupos de amigos se conocen entre si, entonces cada indv de un grupo por lo general tiene coeficiente de clust de  1

## (80 % ) Scripts, código, texto y gráficas


1. **Karate** 

Considera la red del club de Karate de Zachary. [Acá](https://en.wikipedia.org/wiki/Zachary%27s_karate_club) puedes leer sobre eso.
 En igraph la gráfica está precargada
```{r message=FALSE, warning=FALSE}
library(igraph)
karatekid<-make_graph("Zachary")
karatekid
```
 - ¿Cuántos nodos y conexiones tiene? R= Tiene 34 nodos y un total de 78 conexiones
 - ¿Quiénes son los nodos y cuál es la regla de conexión? R= Los nodos son los miembros del club de Karate y la conexión se da por la interacción de estos fuera del club
 - ¿Qué tan densa es la red? R= Sacamos el valor de L (el limite), para posteriormente compararlo con el numero real de conexiones que son 74
 $L= \dfrac{34(33)}{2}= 561\\\\$
 
 $\dfrac{78}{561} = 0.1390374 $
 - ¿Cómo obtienes la matriz de adyacencia? R= Pasando el objeto as.matrix(), en este caso, igual existe la función as_adjacency_matrix(), pero nos arroja el mismo resultado que as.matrix().
 
```{r message=FALSE, warning=FALSE}
library(igraph)
karatekid<-make_graph("Zachary")
karatekid <- as.matrix(karatekid)
karatekid
```

 - ¿Es una red dirigida, pesada? R= Es una red no dirigida y no pesada
 - Calcula y gráfica la distribución de conectividades R=
```{r message=FALSE, warning=FALSE}
library(igraph)
karatekid<-make_graph("Zachary")

#sacamos los valores de conexiones, pero los graficamos de una vez con la función degree.dsitribution() y lo ploteamos
distriedg <- degree.distribution(karatekid)
plot(distriedg)
```
 
 - Calcula el diámetro, la matriz de distancias y la distancia promedio R=

```{r}
library(igraph)
karatekid<-make_graph("Zachary")
plot(karatekid)

diameter(karatekid) #sacamos el diametro con la función

distmatrx <- distances(karatekid) #hacemos el objeto con las distancias que las da como matrix
distmatrx <- as.matrix(distmatrx) #hacemos el objeto a matrix

mean_distance(karatekid) #sacamos el promedio de las distancias
```

 - Encuentra la trayectoria de los nodos más alejados. 
 
```{r}
library(igraph)
karatekid <- make_graph("Zachary")

get_diameter(karatekid)
# nos da la trayectoria de los mas alejados que son usados en el diametro
```
 
 - Existen nodos con coefeiciente de clusterización 1. ¿Qué significa?
 R=Respecto a lo que significa los nodos y las conexiones, implica que son un grupo de chicos que interaccionan fuera del club, por que el hecho de interaccionar fuera ya los conecta y un grupo todos interaccionan con todos y en si es que una persona habla con su gupo y su grupo se hablan entre ellos fuera del club
 
 - Mide , con al menos tres medidas de centralidad, los nodos más importantes.
 
```{r}
library(igraph)
karatekid <- make_graph("Zachary")
katbet <- betweenness(karatekid)
katbet

kateig <- eigen_centrality(karatekid)
kateig

katpag <- page_rank(karatekid)
katpag
```
 
 
 
 **Explica  e interpreta tus resultados**. 
 
 Los nodos más importantes se pueden considerar aquellos con mayor nivel de centralidad por que son los más "famosos", pues son con los que interacciona más gente fuera del club, en este caso son el nodo 1 y el nodo 34, que en las tres medidas de centralidad tuvieorn los valore más altos, de igual manera en los 3 el nodo 33 se ve con un valor alto, peor no tanto como los 34 y 1. al ver la red en plot, se puede observar que son nodos que conetan con muchos y suponiendo la historia de esta red, se puede pensar que al menos los nodos uno de los nodos son el entrenador, tal vez otro entrenador que consiguieron y a lomejor si esta incluido pero recuerdo que no, el director, por que solo menciona una disputa con el director, pero no se si lo incluyeron en la red.
 
 2. **Amigues**
 
 A partir de la red de amigues que vimos en clase, en su versión no ponderada, contesta lo siguiente:
 
 - Escribe una función que calcule el número de amigos que tiene cualquier persona arbitraria y lo compare con el número de los amigos de estos.
 
```{r}
library(igraph)


based<-read.csv("GF_Tarea_01_2023_files1/RedAmiguesPonderadaGF2023 - Hoja 1.tsv",dec=",",sep="\t")
based<- based[,-1] #eliminar la columna de nombre
rownames(based)<- colnames(based) #asignar los nombres de renglones a columnas
baselim <-based[-c(3,15,32),-c(3,15,32)] #eliminar los que no ontestaron, haciendola simetrica
baselim<- as.matrix(baselim) #pasarla a matrix
diag(baselim)<- 0 #eliminar valores en la diagonal
nopondecasa <- ifelse(baselim>=0.5,1,0) #poner el valor de la red, para hacerla no pesada
redcasa_noponde <- graph_from_adjacency_matrix(nopondecasa,mode= "directed")  #asignarla a un objeto de igraph
###################


amigosfun <- function(x){
  
  vato <- c(sample(1:length(V(x)),1)) #sacamos a una persona al azar de la base de datos
  #(V(x)$name[ekiz])
  conocidos <- x[vato,] #sacamos todas sus "conexiones" del vato (conocidos y amigos)
  conomatrix <- as.matrix(conocidos) #lo pasamos a matrix
  
  reales <- which(conomatrix == 1) #seleccionamos solo aquellos que son sus amigos, quitando a los conocidos (aquellos que no considera amigos = 0) y lo asignamos a reales (que son sus amigos de verdad)
  
 
  cantidad <- length(reales) #la cantidad o length(reales) y sera la cantidad de amigos que el tiene, pq solo incluye a aquellos que si son amigos
  
  pe <- 1 #asignamos una variable de conteo
  for (i in 1:length(reales)) {  #empezamos un for, que sera del tamaño de sus amigos reales, para comprobar todos sus amigos con el
  
    
    suamigo <-reales[pe] #saca el primer numero de su primer amigo, que es un objeto de la red inicial
    
    #(V(x)$name)[suamigo] nombre de su amigo , sacamos el nombre de su amigo respecto al valor de los reales que nos da un numero del objeto original igraph
    amigos_d_ami <- sum(x[suamigo]) #hacemos la suma de su amigo, sera el numero de sus amigos, pues solo aquellos que tienen valor de 1 seran considerados entonces una unidad 1, es un amigo, se suman los 1 y da el valor total de amigos, es lo mismo si hacemos un objeto que seleccione a los que tienen valor de 1, y sacar el length()
    
   
    
    
    print(paste0((V(x)$name[vato]), " tiene ", length(reales), " amigos, mientras que su amigx ", (V(x)$name)[suamigo], " tiene ", amigos_d_ami )) 
   
    pe <- pe + 1 #va aumentando el valor de pe, para que el siguiente, saque el numero de la posicion 2 dle vector de los amigos reales de la persona arbitraria
    
    #asi hasta que cabe con todos los amigos
}
  }
redprueba <- redcasa_noponde
amigosfun(redprueba) 
```
 
 
 - Escribe una función que te de la trayectoria más larga entre dos nodos arbitrarios de la red.  
 
```{r}
library(igraph)
based<-read.csv("GF_Tarea_01_2023_files1/RedAmiguesPonderadaGF2023 - Hoja 1.tsv",dec=",",sep="\t")
based<- based[,-1] #eliminar la columna de nombre
rownames(based)<- colnames(based) #asignar los nombres de renglones a columnas
baselim <-based[-c(3,15,32),-c(3,15,32)] #eliminar los que no ontestaron, haciendola simetrica
baselim<- as.matrix(baselim) #pasarla a matrix
diag(baselim)<- 0 #eliminar valores en la diagonal
nopondecasa <- ifelse(baselim>=0.5,1,0) #poner el valor de la red, para hacerla no pesada
redcasa_noponde <- graph_from_adjacency_matrix(nopondecasa,mode= "directed")  #asignarla a un objeto de igraph
###################


maximostray <- function(base1){
  max1 <- vcount(base1)-1
  a<- 1
  b<-1
  direct <- get.adjacency(base1)
  direct
  
  for (i in 0:max1) {
    a<- a+1
    b<- b+1
  }
  for (k in 0:max1) {
  
    b<- b+1
  }
  
 redcasa_noponde[i,k]<- length(get.all.shortest.paths(base1,from=i, to= k, mode="out"))
  print(paste0("el camino más largo es ", redcasa_noponde[i,k]))
  
  
}

maximostray(redcasa_noponde)
```
este no me salio :c, lo saque de internet y pues lo intente adaptar, pero en si ando viendo que lo que hace es como tomar todos los valores y sacar el más grande de todas las trajectorias, pero no toma una y saca todas y de ai sacar el mas grandes, o sea compara trayectorias minimas entre otras trayectorias minimas y de ahi saca el más grande, pero no busca la trayectoria maxima 
 
 
 - Enceuntra las dos personas más populares.
 
```{r}
library(igraph)


based<-read.csv("GF_Tarea_01_2023_files1/RedAmiguesPonderadaGF2023 - Hoja 1.tsv",dec=",",sep="\t")
based<- based[,-1] #eliminar la columna de nombre
rownames(based)<- colnames(based) #asignar los nombres de renglones a columnas
baselim <-based[-c(3,15,32),-c(3,15,32)] #eliminar los que no ontestaron, haciendola simetrica
baselim<- as.matrix(baselim) #pasarla a matrix
diag(baselim)<- 0 #eliminar valores en la diagonal
nopondecasa <- ifelse(baselim>=0.5,1,0) #poner el valor de la red, para hacerla no pesada
redcasa_noponde <- graph_from_adjacency_matrix(nopondecasa,mode= "directed")  #asignarla a un objeto de igraph
###################

sort(degree(redcasa_noponde, mode="in"), decreasing = T)[1:2]

#las personas más famosas son Mayra y Vale Ibarra por que son las que más gente considera su amigo


```
 
 
 3. **Red PPI**
 
 A partir de la red de interacción proteína-proteína (PPI) de la levadura que se encuentra en la bilbioteca `igraphdata` Elabora un script que conteste lo siguiente:
 
 - Encuentre qué tipo de distribución de conectividades tiene. Haz un ajuste en log-log para ver que tipo de distribución podría ser.
 - Encuentra las diez proteínas más conectadas
 - Calcula el diámetro y promedio de las distancias
 - Crea una función que, a partir de  eliminar al azar un noodo de la red genere el promedio d elas distancias después de eliminar $n=1,2,3,\ldots, 100$ nodos al azar
 - Crea una función que elimine las proteínas más conectadas y calcule el promedio de las distancias cad vez que se remueve un nodo.
 - Calcula el proemdio del coeficiente de clusterización. ¿Hay proteínas que tengan un coeficiente de clusterización de 1? Eso qué significa.
 
```{r}
library(igraph)
library(igraphdata)
data(yeast)
#- Encuentre qué tipo de distribución de conectividades tiene. Haz un ajuste en log-log para ver que tipo de distribución podría ser.
plot(degree.distribution(yeast, mode = "all"))
lev <- degree(yeast, mode="in")

fit1 <- fit_power_law(lev+1,10)
fit1$alpha

fit1$logLik 
#- Encuentra las diez proteínas más conectadas
uno <- sort(degree(yeast), decreasing = T)[1:100]
delete.vertices(yeast, uno)
mean_distance(yeast)
#- Calcula el diámetro y promedio de las distancias
diameter(yeast)
mean_distance(yeast)
#- Crea una función que, a partir de  eliminar al azar un noodo de la red genere el promedio d elas distancias después de eliminar $n=1,2,3,\ldots, 100$ nodos al azar

promelim <- function(x){
  for (i in 1:100) {

   x <- delete.vertices(x,c(sample(1:length(V(x)),1))) #eliminam sample(1:length(V(x)),1), donde sacamos los valores o vemos los valores del 1 a la longitud de V (NODOS)
  #de la red que es ekiz y el 1 al final se especifica pq solo queremos uno valor, si quisieramos mas ponemos mas valores ahi y ese 1 pertenece a la funcion sample
  print(paste0("el promedio de las distancias es ", mean_distance(x)))
  
  } 
}
promelim(yeast)

#- Crea una función que elimine las proteínas más conectadas y calcule el promedio de las distancias cad vez que se remueve un nodo.

eliminfamo <- function(x,nm){

  masprot <- sort(degree(yeast), decreasing = T)[1:nm]
masprot
p <- 1
for (i in 1:nm) {
  
  x <- delete.vertices(x, masprot[p])
  
  p <- p+1

  print(paste0("El promedio de las distancias ahora es ", mean_distance(x)))
    
}

}
eliminfamo(yeast,10)
data(yeast)

#- Calcula el proemdio del coeficiente de clusterización. ¿Hay proteínas que tengan un coeficiente de clusterización de 1? Eso qué significa.
transitivity(yeast)#este es el promedio
transitivity(yeast,type="local") #saca el promedio de cada una
```
 
 Discute tus resultados.
 La distribución de es de tipo free-scale, donde muy pocos nodos tienen una gran cantidad de conexiones
 
 De igual manera al eliminar los 100 nodos al azar pues no se vio afectado el promedio de la distancias, pue los nodos pudieron tener una do sola conexion y muhos podrían estar conectados entre si, teniendo el mismo valor de distancia que el original
 
 Al eliminar los 10 más importantes, pues se esperaba que fuera un ca,bio drastico en el promedio de las distancias, sin embargo no, a pesar de eliminar las 10 proteínas más conectadas no hubo un efecto tan grande, solo pasanto el promedio a 5.10, Por un momento pense que era por la cantidad de proteínas importantes, tal vez hay más proteínas importantes que solo difieren en una conexion, entonces elimine 100 y pues el promedio solo fue hasta 5.16. Por lo que podría decirse que es una red robusta, muy robusta, pues a pesar de eliminar a sus 100 mejores proteínas, sigue teniendo el promedio de distancia muy similar. Por loq eu se podría pensar que todas su proteínas tienen muchas conexiones o  almenos gran parte de ellas.
 
 En el cofeciicente de clusterización, se observo un promedio de 0.46 y con la misma función pero poniendo tipo local, nos daba el coeficiente para cada una de las proteínas y había varias que tenian un valor de 1 y otras con NaN, pensaria que las de valor NaN tal vez no estan conectadas, por lo que no tienen valor y aquellas que tenian valor 1, implica que las proteínas con las que se conecta, se conectan todas entre si, por lo que esto la puede hacer muy robusta a la red.

4. Redes biológicas
 
 Ve a al [Network Repository](https://networkrepository.com/bn-mouse-visual-cortex-1.php) y descarga la red en formato lista de adyacencia. Explica que representam  los nodos y las conectividades. 
 
 Escribe código que resuelva lo siguiente:
 
 - Cargue y genere una gráfica en `igraph`. -
 
```{r}
library(igraph)

cerebro <-read.graph("GF_Tarea_01_2023_files1/bn-mouse_visual-cortex_1.edges")


plot(cerebro)

bet2 <- betweenness(cerebro)#metodo de centrality 
bet2

eig2 <- eigen_centrality(cerebro) #metodo de centrality
eig2

pag2 <- page_rank(cerebro) #metodo de centrality
pag2


#todos los layouts disponibles




plot(cerebro, layout= layout_as_star(cerebro))

plot(cerebro, layout= layout_as_tree(cerebro))

plot(cerebro, layout= layout_in_circle(cerebro))

plot(cerebro, layout= layout_nicely(cerebro))

plot(cerebro, layout= layout_on_grid(cerebro))

plot(cerebro, layout= layout_on_sphere(cerebro))

plot(cerebro, layout= layout_randomly(cerebro))

plot(cerebro, layout= layout_with_dh(cerebro))

plot(cerebro, layout= layout_with_fr(cerebro))

plot(cerebro, layout= layout_with_gem(cerebro))

plot(cerebro, layout= layout_with_graphopt(cerebro))

plot(cerebro, layout= layout_with_kk(cerebro))

plot(cerebro, layout= layout_with_lgl(cerebro))

plot(cerebro, layout= layout_with_mds(cerebro))

plot(cerebro, layout= layout_with_sugiyama(cerebro))

```
 
 - Genera la gráfica con todos los layouts disponibles. 
 
 
 - Grafica la red con al menos tres medidas de centralidad. 
```{r}
library(igraph)

redratonb <-read.graph("GF_Tarea_01_2023_files1/bn-mouse_visual-cortex_1.edges")

bet2 <- betweenness(redratonb)
bet2

eig2 <- eigen_centrality(redratonb)
eig2

pag2 <- page_rank(redratonb)
pag2


```
 
 
 - ¿Qué tan densa es la red?
 $L= \dfrac{N(N-1)}{2}= \dfrac{29*28}{2}= \dfrac{812}{2}=406$
 
 $D=\dfrac{conexiones \ reales}{L} = \dfrac{44}{406}=0.108 \\ \textbf{La red es poco densa}$ 
 - Clusteriza la red con al menos tres métodos de clusterización. Gráfica la red con esos métodos.
 
```{r}
library(igraph)

redratonb <-read.graph("GF_Tarea_01_2023_files1/bn-mouse_visual-cortex_1.edges")
plot(redratonb)
redratonb

betw1 <- cluster_edge_betweenness(redratonb)
plot(betw1, redratonb)

inf1 <- cluster_infomap(redratonb)
plot(inf1, redratonb)

wak1 <- cluster_walktrap(redratonb) 
plot(wak1, redratonb)
```

 
 
 
